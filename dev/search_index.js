var documenterSearchIndex = {"docs":
[{"location":"#PatentsLens-1","page":"PatentsLens","title":"PatentsLens","text":"","category":"section"},{"location":"#Methods-1","page":"PatentsLens","title":"Methods","text":"","category":"section"},{"location":"#","page":"PatentsLens","title":"PatentsLens","text":"Modules = [PatentsLens]\nOrder   = [:function]","category":"page"},{"location":"#PatentsLens.merge_applicants!-Tuple{LensDB, String}","page":"PatentsLens","title":"PatentsLens.merge_applicants!","text":"merge_applicants!(db::LensDB, regex::String; new_name, new_country) -> SQLite.Query\n\n\nmerge_applicants!(\n    db::LensDB,\n    regex::String,\n    kwargs...\n)\n\nMerge all applicants whose names match the regular expression regex into one applicant. The new applicant will have the id, name and country of the first matching applicant, unless otherwise specified using the new_name and new_country parameters. All references will be updated to point to the new applicant.\n\nOptional keyword arguments:\n\nnew_name: A String with the name for the new applicant entry\nnew_country: A String with the country code for the new applicant entry\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.merge_applicants!-Tuple{LensDB, Vector{Int64}}","page":"PatentsLens","title":"PatentsLens.merge_applicants!","text":"merge_applicants!(db::LensDB, applicants::Vector{Int64}; new_name, new_country) -> SQLite.Query\n\n\nmerge_applicants!(\n    db::LensDB,\n    applicants::Vector{Int},\n    kwargs...\n)\n\nMerge a list of applicants identified by their IDs into one applicant. The new applicant will have the name and country of the first listed applicant, unless otherwise specified using the new_name and new_country keyword arguments. All references will be updated to point to the new applicant.\n\nOptional keyword arguments:\n\nnew_name: A String with the name for the new applicant entry\nnew_country: A String with the country code for the new applicant entry\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.apply_application_filter!-Tuple{LensDB, PatentsBase.AbstractFilter}","page":"PatentsLens","title":"PatentsLens.apply_application_filter!","text":"apply_application_filter!(db::LensDB, filter::PatentsBase.AbstractFilter) -> SQLite.Query\n\n\nApply filter to database db, generating a temporary table of matching applications. \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.apply_family_filter!-Tuple{LensDB, PatentsBase.AbstractFilter}","page":"PatentsLens","title":"PatentsLens.apply_family_filter!","text":"apply_family_filter!(db::LensDB, filter::PatentsBase.AbstractFilter) -> SQLite.Query\n\n\nApply filter to database db, generating a temporary table of matching patent families. \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.build_index!-Tuple{SQLite.DB}","page":"PatentsLens","title":"PatentsLens.build_index!","text":"build_index!(db::SQLite.DB)\n\n\nBuild the key search index of the database db. This has no effect on the FTS5 full-text search index.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.bulk_insert_apps!-Tuple{SQLite.DB, Vector{LensApplication}}","page":"PatentsLens","title":"PatentsLens.bulk_insert_apps!","text":"bulk_insert_apps!(db::SQLite.DB, apps::Vector{LensApplication}) -> String\n\n\nInsert the applications listed in apps into the database db, replacing existing data on conflict, but preserving and extending party, family and citation relation graphs.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.clear_filter!-Tuple{LensDB}","page":"PatentsLens","title":"PatentsLens.clear_filter!","text":"clear_filter!(db::LensDB) -> SQLite.Query\n\n\nRemove all active filters from a PatentsLens database. \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.date_to_text-Tuple{Dates.Date}","page":"PatentsLens","title":"PatentsLens.date_to_text","text":"date_to_text(date::Dates.Date) -> String\n\n\nConvert a Date to a text format for storage in SQLite. \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.db-Tuple{LensDB}","page":"PatentsLens","title":"PatentsLens.db","text":"db(ldb::LensDB) -> SQLite.DB\n\n\nReturn the SQLite.DB wrapped by ldb. \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.db_key","page":"PatentsLens","title":"PatentsLens.db_key","text":"Helper function to return database table or column names or key values for certain dispatch types. \n\n\n\n\n\n","category":"function"},{"location":"#PatentsLens.doc_key-Tuple{LensApplication}","page":"PatentsLens","title":"PatentsLens.doc_key","text":"doc_key(a::LensApplication) -> String\n\n\nReturn a String with the full document key of application a\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.docdb_id-Tuple{LensApplication}","page":"PatentsLens","title":"PatentsLens.docdb_id","text":"docdb_id(a::LensApplication) -> Union{Nothing, Int64}\n\n\nReturn an Int representing the database ID of application a, or nothing if the field is missing\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.drop_index!-Tuple{SQLite.DB}","page":"PatentsLens","title":"PatentsLens.drop_index!","text":"drop_index!(db::SQLite.DB)\n\n\nDrop the key search index of the database db. This has no effect on the FTS5 full-text search index.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.ignore_fulltext!","page":"PatentsLens","title":"PatentsLens.ignore_fulltext!","text":"ignore_fulltext!() -> Any\nignore_fulltext!(toggle::Bool) -> Any\n\n\nToggle whether PatentsLens should skip full text information when importing data files. This can improve performance and might be needed for large datasets to fit into memory.\n\n\n\n\n\n","category":"function"},{"location":"#PatentsLens.initdb!-Tuple{SQLite.DB}","page":"PatentsLens","title":"PatentsLens.initdb!","text":"initdb!(db::SQLite.DB)\n\n\nInitialize the schema of the database db. This removes all existing PatentsLens data! \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.language-Tuple{LensApplication}","page":"PatentsLens","title":"PatentsLens.language","text":"language(a::LensApplication) -> Union{Nothing, String}\n\n\nReturn a String with the language code of application a, or nothing if the field is missing\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.list_placeholder-Tuple{Int64}","page":"PatentsLens","title":"PatentsLens.list_placeholder","text":"list_placeholder(n::Int64) -> String\n\n\nGenerate a placeholder for a list of n elements in an SQLite query\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.load_jsonl!-Tuple{LensDB, String}","page":"PatentsLens","title":"PatentsLens.load_jsonl!","text":"load_jsonl!(db::LensDB, path::String; chunk_size, skip_on_error, rebuild_index) -> Union{Nothing, Bool}\n\n\nload_jsonl!(db::LensDB, path::String, kwargs...)\n\nRead all application data from the Lens.org JSON lines data file at path, and store it in the  SQLite database db. The database must be set up with the proper table schema beforehand.\n\nOptional keyword arguments:\n\nchunk_size: controls how many lines are read into memory before being bulk-inserted into the database.   Higher values will improve speed at the cost of requiring more memory.\nskip_on_error: If true, loading process will not terminate when encountering a parsing error,   but continue with the next record instead.\nrebuild_index: If true (default), the search index for the database will be dropped and fully rebuilt instead of updating it.   This tends to be faster when importing a large amount of data relative to the amount already in the database.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.publication_type-Tuple{LensApplication}","page":"PatentsLens","title":"PatentsLens.publication_type","text":"publication_type(a::LensApplication) -> String\n\n\nReturn a String with the document type of application a\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.query_select_applications-Tuple{PatentsBase.AbstractFilter}","page":"PatentsLens","title":"PatentsLens.query_select_applications","text":"query_select_applications(f::PatentsBase.AbstractFilter) -> PatentsLens.UnboundQuery\n\n\nGenerate an SQLite query to select the Lens IDs of all applications matching f.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.query_select_families-Tuple{PatentsBase.AbstractFilter}","page":"PatentsLens","title":"PatentsLens.query_select_families","text":"query_select_families(f::PatentsBase.AbstractFilter) -> PatentsLens.UnboundQuery\n\n\nGenerate an SQLite query to select the family IDs of all families matching f.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.read_jsonl-Tuple{String}","page":"PatentsLens","title":"PatentsLens.read_jsonl","text":"read_jsonl(path::String; skip_on_error) -> Vector{LensApplication}\n\n\nread_jsonl(path::String, kwargs...)\n\nReturn a Vector{LensApplication} with all applications from the Lens.org JSON lines data file at path.\n\nOptional keyword arguments:\n\nskip_on_error: If true, loading process will not terminate when encountering a parsing error,   but continue with the next record instead.\n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.set_pragmas!-Tuple{SQLite.DB}","page":"PatentsLens","title":"PatentsLens.set_pragmas!","text":"set_pragmas!(db::SQLite.DB)\n\n\nSet the required pragmas on the database connection db. \n\n\n\n\n\n","category":"method"},{"location":"#PatentsLens.validate_inj-Tuple{String}","page":"PatentsLens","title":"PatentsLens.validate_inj","text":"validate_inj(s::String) -> Bool\n\n\nValidate a string can be safely pasted into a SQL query without injection risk\n\n\n\n\n\n","category":"method"},{"location":"#Types-1","page":"PatentsLens","title":"Types","text":"","category":"section"},{"location":"#","page":"PatentsLens","title":"PatentsLens","text":"Modules = [PatentsLens]\nOrder   = [:type]","category":"page"},{"location":"#PatentsLens.LensAbstract","page":"PatentsLens","title":"PatentsLens.LensAbstract","text":"struct LensAbstract <: PatentsBase.AbstractShortDescription\n\nStruct representing the abstract or short description of a patent application in the Lens.org format\n\nFields:\n\nabstract::Vector{PatentsLens.LensLocalizedText}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensApplicant","page":"PatentsLens","title":"PatentsLens.LensApplicant","text":"struct LensApplicant <: PatentsBase.AbstractApplicant\n\nStruct representing a patent applicant in the Lens.org format\n\nFields:\n\nresidence::Union{Nothing, String}\nextracted_name::Union{Nothing, PatentsLens.LensExtractedName}\nid::Union{Nothing, Int64}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensApplication","page":"PatentsLens","title":"PatentsLens.LensApplication","text":"struct LensApplication <: PatentsBase.AbstractApplication\n\nStruct representing a patent application retrieved from Lens.org.\n\nFields:\n\nlens_id::String\npublication_type::String\njurisdiction::String\ndoc_number::String\nkind::String\ndate_published::Union{Nothing, Dates.Date}\ndoc_key::String\ndocdb_id::Union{Nothing, Int64}\nlang::Union{Nothing, String}\nbiblio::PatentsLens.LensBiblio\nabstract::Union{Nothing, LensAbstract}\nclaims::Union{Nothing, PatentsLens.LensClaims}\ndescription::Union{Nothing, LensFulltext}\nfamilies::PatentsLens.LensFamilies\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensApplicationReference","page":"PatentsLens","title":"PatentsLens.LensApplicationReference","text":"struct LensApplicationReference <: PatentsBase.AbstractApplicationID\n\nStruct representing a reference to a patent application in the Lens.org format\n\nFields:\n\ndocument_id::PatentsLens.LensDocumentID\nlens_id::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensClaim","page":"PatentsLens","title":"PatentsLens.LensClaim","text":"struct LensClaim <: PatentsBase.AbstractClaim\n\nStruct representing a patent claim in the Lens.org format. \n\nFields:\n\nclaim::Vector{PatentsLens.LensLocalizedText}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensDB","page":"PatentsLens","title":"PatentsLens.LensDB","text":"struct LensDB <: PatentsBase.AbstractDataSource\n\nLensDB(db::SQLite.DB)\nLensDB(file::String)\n\nWrapper around an SQLite database containing PatentsLens data.\n\nThe constructor will create a new database if one does not exist at the specified location. It will also initialize the database with the correct schema if necessary.\n\nFields:\n\ndb::SQLite.DB\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensFamily","page":"PatentsLens","title":"PatentsLens.LensFamily","text":"struct LensFamily <: PatentsBase.AbstractFamily\n\nStruct representing an aggregated patent family in the Lens.org format\n\nFields:\n\nmembers::Vector{LensApplication}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensForwardCitation","page":"PatentsLens","title":"PatentsLens.LensForwardCitation","text":"struct LensForwardCitation <: PatentsBase.AbstractPatentCitation\n\nStruct representing a forward citation (\"cited by\"-entry) in the Lens.org format\n\nFields:\n\nref::LensApplicationReference\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensFulltext","page":"PatentsLens","title":"PatentsLens.LensFulltext","text":"struct LensFulltext <: PatentsBase.AbstractFulltext\n\nStruct representing the full text of a patent application in the Lens.org format\n\nFields:\n\ntext::String\nlang::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensInventor","page":"PatentsLens","title":"PatentsLens.LensInventor","text":"struct LensInventor <: PatentsBase.AbstractInventor\n\nStruct representing a patent inventor in the Lens.org format\n\nFields:\n\nresidence::Union{Nothing, String}\nextracted_name::Union{Nothing, PatentsLens.LensExtractedName}\nid::Union{Nothing, Int64}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensNPLCitation","page":"PatentsLens","title":"PatentsLens.LensNPLCitation","text":"struct LensNPLCitation <: PatentsBase.AbstractNPLCitation\n\nStruct representing a non-patent literature (NPL) citation in the Lens.org format\n\nFields:\n\nsequence::Union{Nothing, Int64}\nnplcit::Union{Nothing, PatentsLens.LensNPLCitationInner}\ncited_phase::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensPatentCitation","page":"PatentsLens","title":"PatentsLens.LensPatentCitation","text":"struct LensPatentCitation <: PatentsBase.AbstractPatentCitation\n\nStruct representing a patent citation in the Lens.org format\n\nFields:\n\nsequence::Union{Nothing, Int64}\npatcit::Union{Nothing, LensApplicationReference}\ncited_phase::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensPortfolio","page":"PatentsLens","title":"PatentsLens.LensPortfolio","text":"struct LensPortfolio <: PatentsBase.AbstractPortfolio\n\nStruct representing a party's portfolio of patent applications\n\nFields:\n\nowner::PatentsBase.AbstractParty\napplications::Union{Nothing, Vector{LensApplication}}\nfamilies::Union{Nothing, Vector{LensFamily}}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensTitle","page":"PatentsLens","title":"PatentsLens.LensTitle","text":"struct LensTitle <: PatentsBase.AbstractTitle\n\nStruct representing the title of a patent application in the Lens.org format\n\nFields:\n\ntitle::Vector{PatentsLens.LensLocalizedText}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.LensDocumentID","page":"PatentsLens","title":"PatentsLens.LensDocumentID","text":"struct LensDocumentID <: PatentsBase.AbstractApplicationID\n\nStruct implementation of PatentsBase.AbstractApplicationID in the Lens.org format\n\nFields:\n\njurisdiction::String\ndoc_number::String\nkind::Union{Nothing, String}\ndate::Union{Nothing, Dates.Date}\n\n\n\n\n\n","category":"type"},{"location":"#PatentsLens.UnboundQuery","page":"PatentsLens","title":"PatentsLens.UnboundQuery","text":"struct UnboundQuery\n\nStruct representing a query with placeholders along with the parameters to bind to those placeholders\n\nFields:\n\ntext::String\nparams::Vector{String}\n\n\n\n\n\n","category":"type"}]
}
